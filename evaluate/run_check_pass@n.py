import os
os.environ['HF_HOME'] = '/root/autodl-tmp/hf-mirror'
os.environ['HF_ENDPOINT'] = "https://hf-mirror.com"
from openai import OpenAI, AsyncOpenAI
from dotenv import load_dotenv
import argparse
import asyncio
import json
from tqdm import tqdm
load_dotenv()

PROMPT_TEMPLATE = """
I will show you a [Math Problem], an [Answer], and an [AI's Solution] generated by an AI assistant. Your task is to determine if the **final answer** in the [AI's Solution] matches the answer in the [Answer].

--------------------------------------------------

[Math Problem]

{problem}

[Answer]

{answer}

[AI's Solution]

{response}

--------------------------------------------------

Please evaluate whether the **final answer** in the [AI's Solution] is correct, based solely on whether it matches the **final answer** in the [Answer].

Note that the [AI's Solution] only needs to reach the same **final answer** to be considered correct.

Reply with only "Yes" or "No".
"""


# client = OpenAI(
#     api_key=os.getenv("DASHSCOPE_API_KEY"),
#     base_url=os.getenv("DASHSCOPE_BASE_URL"),
# )

client = AsyncOpenAI(
    api_key=os.getenv("DEEPSEEK_API_KEY"),
    base_url=os.getenv("DEEPSEEK_BASE_URL"),
)

async def _make_request(args, problem: str, answer: str, response: str) -> list[str]:
    """Make a single API request and return all generated responses."""
    context = PROMPT_TEMPLATE.format(
        problem=problem,
        answer=answer,
        response=response
    )

    messages = [
        {"role": "user", "content": context}
    ]
    response = await client.chat.completions.create(
        model=args.model,
        messages=messages,
        temperature=0.,
    )
    return response.choices[0].message.content.strip()


async def _retry_request(args, problem: str, answer: str, response: str, retries: int = 3, delay: int = 5) -> str:
    """
    Attempt to make an API request with retries.

    Args:
        args: Command line arguments. 
        problem (str): The math problem.
        answer (str): The reference solution/answer.
        response (str): The AI's response to verify.
        retries (int): The number of attempts to try. 
        delay (int): Seconds to wait between attempts.

    Returns:
        str: "Yes" or "No" indicating if the response matches the answer. 

    Raises:
        Exception:  The last exception caught if all retries fail.
    """
    last_exception = None
    for attempt in range(1, retries + 1):
        try:
            result = await _make_request(args, problem, answer, response)
            return result
        except Exception as e:
            last_exception = e
            print(f"Attempt {attempt} failed with error: {e}")
            if attempt < retries:
                await asyncio.sleep(delay)
    raise last_exception


async def verify_single_item(args, item: dict) -> dict:
    """
    Verify all responses for a single item concurrently.

    Args:
        args: Command line arguments. 
        item: Dictionary containing problem, responses, and answer.

    Returns:
        Dictionary with problem, responses, answer, and labels.
    """
    problem = item["problem"]
    answer = item["answer"]
    responses = item["responses"]

    # Create tasks for all responses in this item
    tasks = [
        _retry_request(args, problem, answer, response)
        for response in responses
    ]

    # Run all verification tasks concurrently
    results = await asyncio.gather(*tasks, return_exceptions=True)

    labels = []
    for i, result in enumerate(results):
        if isinstance(result, Exception):
            print(f"Failed to verify response {i} for problem: {problem[: 50]}...  Error: {result}")
            labels.append("Error")
        else:
            labels.append(result)

    return {
        "problem": problem,
        "responses": responses,
        "answer": answer,
        "labels": labels
    }

async def process_batch(args, batch_data: list[dict]) -> list[dict]:
    """
    Process a batch of items concurrently.

    Args:
        args: Command line arguments. 
        batch_data: List of dictionaries containing problem, responses, and answer.

    Returns:
        List of results with problem, responses, answer, and labels.
    """
    tasks = [
        verify_single_item(args, item)
        for item in batch_data
    ]

    results = await asyncio.gather(*tasks, return_exceptions=True)

    processed_results = []
    for item, result in zip(batch_data, results):
        if isinstance(result, Exception):
            print(f"Failed to process item: {item['problem'][:50]}... Error: {result}")
            processed_results.append({
                "problem": item["problem"],
                "responses": item["responses"],
                "answer":  item["answer"],
                "labels": ["Error"] * len(item["responses"])
            })
        else:
            processed_results.append(result)

    return processed_results


async def run_async(args):
    """Main async function to process the dataset."""
    print(f"Loading json file: {args.filename}")
    with open(args.filename, "r", encoding="utf-8") as f:
        data = json.load(f)

    all_results = []
    total_batches = (len(data) + args.batch_size - 1) // args.batch_size

    print(f"Total items: {len(data)}")
    print(f"Batch size: {args.batch_size}")
    print(f"Total batches: {total_batches}")
    print(f"Interval between batches: {args.interval} seconds")
    print("-" * 50)

    for batch_idx in tqdm(range(total_batches), desc="Processing batches"):
        start_idx = batch_idx * args.batch_size
        end_idx = min(start_idx + args.batch_size, len(data))
        batch_data = data[start_idx:end_idx]

        print(f"\nProcessing batch {batch_idx + 1}/{total_batches} (items {start_idx + 1}-{end_idx})")

        batch_results = await process_batch(args, batch_data)
        all_results.extend(batch_results)

        # Sleep between batches (except for the last batch)
        if batch_idx < total_batches - 1:
            print(f"Sleeping for {args.interval} seconds...")
            await asyncio.sleep(args.interval)

    # Save results to JSON file
    print(f"\nSaving results to {args.output}")
    with open(args.output, "w", encoding="utf-8") as f:
        json.dump(all_results, f, ensure_ascii=False, indent=2)

    print(f"Results saved to {args.output}")


def run(args):
    """Entry point that runs the async main function."""
    asyncio.run(run_async(args))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate LLM responses for math problems")
    parser.add_argument("--filename", type=str, required=True, help="HuggingFace dataset name")
    parser.add_argument("--model", type=str, required=True, help="Model name")
    parser.add_argument("--batch_size", type=int, default=5, help="Batch size for concurrent API calls")
    parser.add_argument("--output", type=str, required=True, help="Output JSON file path")
    parser.add_argument("--interval", type=int, default=5, help="Time interval between batches in seconds")
    args = parser.parse_args()
    run(args)

# client = OpenAI(
#     api_key=os.getenv("DEEPSEEK_API_KEY"),
#     base_url=os.getenv("DEEPSEEK_BASE_URL"),
# )

# problem = "For all angle measures $A^{\\circ}$ greater than $0^{\\circ}$, which of the following expressions is equal to $\\cos A^{\\circ}$: (F) $\\cos (90+A)^{\\circ}$ (G) $\\cos (180-A)^{\\circ}$ (H) $\\cos (180+A)^{\\circ}$ (J) $\\cos (270+A)^{\\circ}$ (K) $\\cos (360-A)^{\\circ}$"
# answer = "K"
# response = "To determine which expression is equal to \\(\\cos A^\\circ\\) for all angle measures \\(A^\\circ > 0^\\circ\\), we will use trigonometric identities. Let's analyze each option step by step.\n\n### Option (F): \\(\\cos (90 + A)^\\circ\\)\nUsing the cosine addition formula:\n\\[\n\\cos (90 + A)^\\circ = -\\sin A^\\circ\n\\]\nThis is not equal to \\(\\cos A^\\circ\\).\n\n### Option (G): \\(\\cos (180 - A)^\\circ\\)\nUsing the cosine subtraction formula and the fact that \\(\\cos (180 - x) = -\\cos x\\):\n\\[\n\\cos (180 - A)^\\circ = -\\cos A^\\circ\n\\]\nThis is not equal to \\(\\cos A^\\circ\\).\n\n### Option (H): \\(\\cos (180 + A)^\\circ\\)\nUsing the cosine addition formula and the fact that \\(\\cos (180 + x) = -\\cos x\\):\n\\[\n\\cos (180 + A)^\\circ = -\\cos A^\\circ\n\\]\nThis is not equal to \\(\\cos A^\\circ\\).\n\n### Option (J): \\(\\cos (270 + A)^\\circ\\)\nUsing the cosine addition formula and the fact that \\(\\cos (270 + x) = \\sin x\\):\n\\[\n\\cos (270 + A)^\\circ = \\sin A^\\circ\n\\]\nThis is not equal to \\(\\cos A^\\circ\\).\n\n### Option (K): \\(\\cos (360 - A)^\\circ\\)\nUsing the cosine subtraction formula and the fact that \\(\\cos (360 - x) = \\cos x\\):\n\\[\n\\cos (360 - A)^\\circ = \\cos A^\\circ\n\\]\nThis is equal to \\(\\cos A^\\circ\\).\n\nThus, the correct expression is \\(\\cos (360 - A)^\\circ\\).\n\nThe final answer is \\(\\boxed{K}\\)."
# context = PROMPT_TEMPLATE.format(
#         problem=problem,
#         answer=answer,
#         response=response
#     )
# completion = client.chat.completions.create(
#     model="deepseek-chat",
#     messages=[
#         {"role": "user", "content": context},
#     ],
#     temperature=0.,
# )

# response = completion.choices[0].message.content
# print("Response:", response)
# print(completion.model_dump_json())